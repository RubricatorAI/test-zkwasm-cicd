"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handler = exports.builder = exports.desc = exports.command = void 0;
const zkwasm_service_helper_1 = require("zkwasm-service-helper");
const promises_1 = __importDefault(require("fs/promises"));
const path_1 = __importDefault(require("path"));
exports.command = "prover-profile";
exports.desc = "Profile Prover nodes statistics and generate report";
const builder = (yargs) => {
    return yargs
        .option("compare-with", {
        describe: "Optional path to a JSON file containing other node statistics",
        type: "string",
    })
        .option("report-out", {
        describe: "Output file path for the report. This is only required if 'compare-with' is also provided",
        type: "string",
    });
};
exports.builder = builder;
const handler = (argv) => __awaiter(void 0, void 0, void 0, function* () {
    const restURL = argv.r;
    const getNodeStatistics = () => __awaiter(void 0, void 0, void 0, function* () {
        let helper = new zkwasm_service_helper_1.ZkWasmServiceHelper(restURL, "", "");
        let args = {
            total: 500,
        };
        let stats = helper
            .queryNodeStatistics(args)
            .then((res) => {
            return res;
        })
            .catch((err) => {
            console.log("Error fetching Current node statistics", err);
            throw err;
        });
        return stats;
    });
    // Get initial node statistics
    let currentStats = [];
    try {
        currentStats = (yield getNodeStatistics()).data;
    }
    catch (err) {
        console.log("Error fetching Current node statistics", err);
        return;
    }
    console.log("Current node statistics fetched");
    console.log("Saving current node statistics locally");
    yield saveNodeStatistics(currentStats, "node_statistics.json");
    console.log("Current node statistics saved locally");
    // Check the compare-with option to load initial statistics from a file
    const compareWith = argv["compare-with"];
    if (compareWith) {
        console.log("Comparing current with previous found at: ", compareWith);
        const statsPath = path_1.default.resolve(compareWith);
        const prevStats = yield loadNodeStatisticsFile(statsPath);
        const report = compareNodeStats(prevStats, currentStats).filter(Boolean);
        // Write report to file
        const outputPath = path_1.default.resolve(argv["report-out"]);
        saveReportFile(report, outputPath);
        console.log(`Prover profile report has been saved to ${outputPath}`);
    }
    else {
        // If no compare-with option is provided, no report will be generated
        console.log("No comparison statistics provided. Exiting...");
    }
});
exports.handler = handler;
// save the statistics locally with a timestamp
function saveNodeStatistics(stats, outFile) {
    return __awaiter(this, void 0, void 0, function* () {
        const rfcdate = new Date().toISOString();
        // append timestamp to the file name
        // Split by '.' and insert timestamp before the last element
        const parts = outFile.split(".");
        const fileName = parts.slice(0, -1).join(".").concat(`_${rfcdate}`);
        const fileExtension = parts[parts.length - 1];
        const statsPath = path_1.default.resolve(`${fileName}.${fileExtension}`);
        yield promises_1.default.writeFile(statsPath, JSON.stringify(stats, null, 2));
    });
}
function loadNodeStatisticsFile(statsPath) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const stats = yield promises_1.default.readFile(statsPath, "utf-8");
            return JSON.parse(stats);
        }
        catch (err) {
            console.error("Error loading local statistics", err);
            return [];
        }
    });
}
function saveReportFile(report, outFile) {
    return __awaiter(this, void 0, void 0, function* () {
        // Check extension of the output file
        const fileExtension = path_1.default.extname(outFile).toLowerCase();
        // create a summary of the report
        const summary = {
            total_nodes: report.length,
            successful_tasks: report.reduce((acc, node) => acc + node.successful_tasks, 0),
            failed_tasks: report.reduce((acc, node) => acc + node.failed_tasks, 0),
            total_tasks: report.reduce((acc, node) => acc + node.total_tasks, 0),
            timed_out_count: report.reduce((acc, node) => acc + node.timed_out_count, 0),
            // Nodes with any successful, failed or timed out tasks (active nodes but not necessarily working)
            active_nodes: report.filter((node) => node.successful_tasks > 0 ||
                node.failed_tasks > 0 ||
                node.timed_out_count > 0).length,
            success_task_nodes: report.filter((node) => node.successful_tasks > 0)
                .length,
            failed_task_nodes: report.filter((node) => node.failed_tasks > 0).length,
            timed_out_nodes: report.filter((node) => node.timed_out_count > 0).length,
        };
        if (fileExtension === ".json") {
            const combinedReport = {
                summary,
                report,
            };
            yield promises_1.default.writeFile(outFile, JSON.stringify(combinedReport, null, 2));
        }
        else if (fileExtension === ".csv") {
            // Create CSV file, put summary at the top
            const summaryHeaders = Object.keys(summary).join(",");
            const summaryRow = Object.values(summary).join(",");
            const defaultHeaders = {
                address: "",
                successful_tasks: 0,
                failed_tasks: 0,
                total_tasks: 0,
                timed_out_count: 0,
                setup_time_diff: 0,
                proof_time_diff: 0,
            };
            const headers = Object.keys(defaultHeaders).join(",");
            const rows = report.map((row) => Object.values(row).join(","));
            const csv = [summaryHeaders, summaryRow, headers, ...rows].join("\n");
            yield promises_1.default.writeFile(outFile, csv);
        }
        else {
            console.error("Unsupported file format. Please use .json or .csv extension.");
        }
    });
}
function compareNodeStats(initialStats, finalStats) {
    return finalStats.map((finalNode) => {
        const initialNode = initialStats.find((node) => node.address === finalNode.address);
        // we can remove some new nodes that are not in the initial stats
        if (!initialNode)
            return null;
        const diff = {
            address: finalNode.address,
            successful_tasks: finalNode.statistics.successful_tasks -
                initialNode.statistics.successful_tasks,
            failed_tasks: finalNode.statistics.failed_tasks - initialNode.statistics.failed_tasks,
            total_tasks: finalNode.statistics.total_tasks - initialNode.statistics.total_tasks,
            timed_out_count: finalNode.statistics.timed_out_count -
                initialNode.statistics.timed_out_count,
        };
        if (finalNode.statistics.setup_timing_stats &&
            initialNode.statistics.setup_timing_stats) {
            diff.setup_time_diff =
                finalNode.statistics.setup_timing_stats.latest_time_taken_secs -
                    initialNode.statistics.setup_timing_stats.latest_time_taken_secs;
        }
        if (finalNode.statistics.proof_timing_stats &&
            initialNode.statistics.proof_timing_stats) {
            diff.proof_time_diff =
                finalNode.statistics.proof_timing_stats.latest_time_taken_secs -
                    initialNode.statistics.proof_timing_stats.latest_time_taken_secs;
        }
        return diff;
    });
}
