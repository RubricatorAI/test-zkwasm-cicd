"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setMaintenanceMode = exports.addPaymentWithTx = exports.addNewPayment = exports.pressureTest = exports.addProvingTask = exports.addNewWasmImage = void 0;
const fs_1 = __importDefault(require("fs"));
const ethers_1 = require("ethers");
const path_1 = require("path");
const util_1 = require("./util");
const zkwasm_service_helper_1 = require("zkwasm-service-helper");
const query_1 = require("./query");
function addNewWasmImage(resturl, absPath, user_addr, imageName, description_url, avator_url, circuit_size, priv, creator_paid_proof, creator_only_add_prove_task, auto_submit_networks, inherited_merkle_data_md5) {
    return __awaiter(this, void 0, void 0, function* () {
        const filename = (0, path_1.parse)(absPath).base;
        let fileSelected = fs_1.default.readFileSync(absPath);
        let md5 = zkwasm_service_helper_1.ZkWasmUtil.convertToMd5(new Uint8Array(fileSelected));
        let prove_payment_src = creator_paid_proof
            ? zkwasm_service_helper_1.ProvePaymentSrc.CreatorPay
            : zkwasm_service_helper_1.ProvePaymentSrc.Default;
        let add_prove_task_restrictions = creator_only_add_prove_task
            ? zkwasm_service_helper_1.AddProveTaskRestrictions.CreatorOnly
            : zkwasm_service_helper_1.AddProveTaskRestrictions.Anyone;
        let info = {
            name: filename,
            image_md5: md5,
            image: fileSelected,
            user_address: user_addr.toLowerCase(),
            description_url: description_url,
            avator_url: avator_url,
            circuit_size: circuit_size,
            prove_payment_src: prove_payment_src,
            auto_submit_network_ids: auto_submit_networks,
            inherited_merkle_data_md5: inherited_merkle_data_md5,
            add_prove_task_restrictions: add_prove_task_restrictions,
        };
        let msg = zkwasm_service_helper_1.ZkWasmUtil.createAddImageSignMessage(info);
        let signature;
        try {
            console.log("msg is:", msg);
            signature = yield (0, util_1.signMessage)(msg, priv);
            console.log("signature is:", signature);
        }
        catch (e) {
            console.log("sign error: ", e);
            return;
        }
        let task = Object.assign(Object.assign({}, info), { signature });
        let helper = new zkwasm_service_helper_1.ZkWasmServiceHelper(resturl, "", "");
        yield helper
            .addNewWasmImage(task)
            .then((res) => {
            console.log("Add Image Response", res);
        })
            .catch((err) => {
            console.log("Add Image Error", err);
        })
            .finally(() => console.log("Finish addNewWasmImage!"));
    });
}
exports.addNewWasmImage = addNewWasmImage;
function addProvingTask(resturl, user_addr, image_md5, public_inputs, private_inputs, proof_submit_mode, priv, enable_logs = true, num = 0) {
    return __awaiter(this, void 0, void 0, function* () {
        let helper = new zkwasm_service_helper_1.ZkWasmServiceHelper(resturl, "", "", enable_logs);
        let pb_inputs = zkwasm_service_helper_1.ZkWasmUtil.validateInputs(public_inputs);
        let priv_inputs = zkwasm_service_helper_1.ZkWasmUtil.validateInputs(private_inputs);
        let info = {
            user_address: user_addr.toLowerCase(),
            md5: image_md5,
            public_inputs: pb_inputs,
            private_inputs: priv_inputs,
            proof_submit_mode: proof_submit_mode,
        };
        let msgString = zkwasm_service_helper_1.ZkWasmUtil.createProvingSignMessage(info);
        let signature;
        try {
            signature = yield (0, util_1.signMessage)(msgString, priv);
        }
        catch (e) {
            if (enable_logs) {
                console.log("error signing message", e);
            }
            throw e;
        }
        let task = Object.assign(Object.assign({}, info), { signature: signature });
        return yield helper
            .addProvingTask(task)
            .then((res) => {
            if (enable_logs) {
                console.log(`#${num} Add Proving task Response`, res);
            }
            return res;
        })
            .catch((err) => {
            if (enable_logs) {
                console.log(`#${num} Add Proving task Error`, err);
            }
            throw err;
        });
    });
}
exports.addProvingTask = addProvingTask;
function sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
}
function runFuncAndGetExecTime(i, func) {
    return __awaiter(this, void 0, void 0, function* () {
        const start = new Date().getTime();
        yield func(i);
        const end = new Date().getTime();
        return end - start;
    });
}
function sendIntervaledRequests(tot_ms, interval_ms, n_req, secs, request_fn, finish_fn) {
    return __awaiter(this, void 0, void 0, function* () {
        const start_t = Date.now();
        let req_cnt = 0;
        for (let curr_t = Date.now(); curr_t - start_t < tot_ms && req_cnt < n_req; curr_t = Date.now()) {
            // Break if reached total runtime limit because requests ran overtime.
            if (secs.value >= tot_ms / 1000) {
                break;
            }
            let time_taken = yield runFuncAndGetExecTime(req_cnt, request_fn);
            req_cnt++;
            yield sleep(Math.max(interval_ms - time_taken, 0));
        }
        finish_fn();
    });
}
function runProveTasks(resturl, user_addr, image_md5s, priv, public_inputs, private_inputs, num_prove_tasks, submit_mode, interval_ms, total_time_ms, original_interval_ms, enable_logs) {
    return __awaiter(this, void 0, void 0, function* () {
        let interval_succ_cnt = 0;
        let interval_fail_cnt = 0;
        let secs = { value: 0 };
        const interval_id = setInterval(() => {
            const msg = interval_succ_cnt == 0 && interval_fail_cnt == 0
                ? "\tNo tasks finished within interval ..."
                : `\tsucc = ${interval_succ_cnt}\tfail = ${interval_fail_cnt}`;
            console.log(`Prove: t = ${secs.value}${msg}`);
            interval_succ_cnt = 0;
            interval_fail_cnt = 0;
            secs.value++;
        }, original_interval_ms);
        let n_success = 0;
        sendIntervaledRequests(total_time_ms, interval_ms, num_prove_tasks, secs, (i) => __awaiter(this, void 0, void 0, function* () {
            // TODO: try catch instead of return boolean
            try {
                yield addProvingTask(resturl, user_addr, image_md5s[i % image_md5s.length], public_inputs, private_inputs, submit_mode, priv, enable_logs, i);
                n_success++;
                interval_succ_cnt++;
            }
            catch (e) {
                interval_fail_cnt++;
                console.log("Error in runProveTasks", e);
            }
        }), () => {
            console.log("\n");
            console.log("-".repeat(72));
            console.log("Finished sending prove requests, cumulative stats:");
            console.log("\tNumber of successful prove tasks sent", n_success, "out of", num_prove_tasks);
            console.log("\tProve task success rate", (n_success / num_prove_tasks) * 100, "%");
            clearInterval(interval_id);
        });
    });
}
function runQueryTasks(resturl, user_address, image_md5s, task_ids, num_query_tasks, interval_ms, total_time_ms, original_interval_ms, enable_logs, query_tasks_only) {
    return __awaiter(this, void 0, void 0, function* () {
        let interval_succ_cnt = 0;
        let interval_fail_cnt = 0;
        let secs = { value: 0 };
        const interval_id = setInterval(() => {
            const msg = interval_succ_cnt == 0 && interval_fail_cnt == 0
                ? "\tNo tasks finished within interval ..."
                : `\tsucc = ${interval_succ_cnt}\tfail = ${interval_fail_cnt}`;
            console.log(`Query: t = ${secs.value}${msg}`);
            interval_succ_cnt = 0;
            interval_fail_cnt = 0;
            secs.value++;
        }, original_interval_ms);
        let n_success = 0;
        sendIntervaledRequests(total_time_ms, interval_ms, num_query_tasks, secs, (_) => __awaiter(this, void 0, void 0, function* () {
            const query_fn = getRandomQuery(image_md5s, task_ids, resturl, user_address, enable_logs, query_tasks_only);
            const success = yield query_fn();
            if (success) {
                n_success++;
                interval_succ_cnt++;
            }
            else {
                interval_fail_cnt++;
            }
        }), () => {
            console.log("\n");
            console.log("-".repeat(72));
            console.log("Finished sending query requests, cumulative stats:");
            console.log("\tNumber of successful query tasks sent", n_success, "out of", num_query_tasks);
            console.log("\tQuery task success rate", (n_success / num_query_tasks) * 100, "%");
            clearInterval(interval_id);
        });
    });
}
function getMd5sAndTaskIds(resturl, user_addr) {
    return __awaiter(this, void 0, void 0, function* () {
        const images_detail = yield (0, query_1.getAvailableImages)(resturl, user_addr, false);
        let image_md5s = [];
        let task_ids = [];
        for (const d of images_detail) {
            if (!image_md5s.find((x) => x === d.md5)) {
                image_md5s.push(d.md5);
            }
            if (!task_ids.find((x) => x === d._id["$oid"])) {
                task_ids.push(d._id["$oid"]);
            }
        }
        return [image_md5s, task_ids];
    });
}
function getRandIdx(length) {
    return Math.floor(Math.random() * length);
}
function getRandomQuery(image_md5s, task_ids, resturl, user_addr, enable_logs, query_tasks_only) {
    const fn_list = [
        () => (0, query_1.queryTask)(task_ids[getRandIdx(task_ids.length)], resturl, enable_logs),
        () => {
            const task_types = ["Setup", "Prove", "Reset"];
            const task_statuses = [
                "Pending",
                "Processing",
                "DryRunFailed",
                "Done",
                "Fail",
                "Stale",
            ];
            return (0, query_1.queryTaskByTypeAndStatus)(task_types[getRandIdx(task_types.length)], task_statuses[getRandIdx(task_statuses.length)], resturl, enable_logs);
        },
    ];
    if (!query_tasks_only) {
        fn_list.push(...[
            () => (0, query_1.queryImage)(image_md5s[getRandIdx(image_md5s.length)], resturl, enable_logs),
            () => (0, query_1.queryUser)(user_addr, resturl, enable_logs),
            () => (0, query_1.queryUserSubscription)(user_addr, resturl, enable_logs),
            () => (0, query_1.queryTxHistory)(user_addr, resturl, enable_logs),
            () => (0, query_1.queryDispositHistory)(user_addr, resturl, enable_logs),
            () => (0, query_1.queryConfig)(resturl, enable_logs),
            () => (0, query_1.queryStatistics)(resturl, enable_logs),
        ]);
    }
    let idx = getRandIdx(fn_list.length);
    return fn_list[idx];
}
function pressureTest(resturl, user_addr, priv, public_inputs, private_inputs, proof_submit_mode, num_prove_tasks, interval_prove_tasks_ms, num_query_tasks, interval_query_tasks_ms, total_time_sec, enable_logs, query_tasks_only, image_md5s_in) {
    return __awaiter(this, void 0, void 0, function* () {
        const total_time_ms = total_time_sec * 1000;
        const total_prove_tasks = num_prove_tasks * Math.floor(total_time_ms / interval_prove_tasks_ms);
        const total_query_tasks = num_query_tasks * Math.floor(total_time_ms / interval_query_tasks_ms);
        const prove_interval_ms = Math.ceil(interval_prove_tasks_ms / num_prove_tasks);
        const query_interval_ms = Math.ceil(interval_query_tasks_ms / num_query_tasks);
        console.log("Total_time_ms", total_time_ms);
        console.log("total_prove_tasks", total_prove_tasks);
        console.log("total_query_tasks", total_query_tasks);
        console.log("prove_interval_ms", prove_interval_ms);
        console.log("query_interval_ms", query_interval_ms);
        console.log("-".repeat(72));
        console.log("Prove target:\tsucc =", num_prove_tasks, "\tper", interval_prove_tasks_ms, "ms");
        console.log("Query target:\tsucc =", num_query_tasks, "\tper", interval_query_tasks_ms, "ms");
        console.log("-".repeat(72));
        console.log("Interval stats:");
        console.log("-".repeat(72));
        const [image_md5s_fetched, task_ids] = yield getMd5sAndTaskIds(resturl, user_addr);
        const image_md5s = image_md5s_in.length === 0 ? image_md5s_fetched : image_md5s_in;
        const tasks = [
            runProveTasks(resturl, user_addr, image_md5s, priv, public_inputs, private_inputs, total_prove_tasks, proof_submit_mode, prove_interval_ms, total_time_ms, interval_prove_tasks_ms, enable_logs),
            runQueryTasks(resturl, user_addr, image_md5s, task_ids, total_query_tasks, query_interval_ms, total_time_ms, interval_query_tasks_ms, enable_logs, query_tasks_only),
        ];
        yield Promise.all(tasks);
    });
}
exports.pressureTest = pressureTest;
/*
export async function addDeployTask(
  resturl: string,
  user_addr: string,
  image_md5: string,
  chain_id: number,
  priv: string
) {
  let helper = new ZkWasmServiceHelper(resturl, "", "");

  let info: DeployParams = {
    user_address: user_addr.toLowerCase(),
    md5: image_md5,
    chain_id: chain_id,
  };
  let msgString = ZkWasmUtil.createDeploySignMessage(info);
  let signature: string;
  try {
    signature = await signMessage(msgString, priv);
  } catch (e: unknown) {
    console.log("error signing message", e);
    return;
  }
  let task: WithSignature<DeployParams> = {
    ...info,
    signature: signature,
  };

  await helper.addDeployTask(task);
  console.log("Finish addDeployTask!");
}*/
function addNewPayment(resturl, providerUrl, amount, priv) {
    return __awaiter(this, void 0, void 0, function* () {
        //Sign a transaction with the users private key, submit it on chain and wait for it to be mined.
        const provider = new ethers_1.ethers.JsonRpcProvider(providerUrl);
        const wallet = new ethers_1.ethers.Wallet(priv, provider);
        const parsedAmount = ethers_1.ethers.parseEther(amount);
        console.log("Depositing " + parsedAmount + " ETH for user " + wallet.address);
        //create the transaction and sign it
        //Get the receiver address from the zkWasm service.
        let helper = new zkwasm_service_helper_1.ZkWasmServiceHelper(resturl, "", "");
        let config = (yield helper.queryConfig());
        let receiverAddress = config.receiver_address;
        console.log("receiverAddress is:", receiverAddress);
        let ans = yield (0, util_1.askQuestion)("Are you sure you want to send " +
            amount +
            " ETH to " +
            receiverAddress +
            "? (y/n)");
        if (ans === "n" || ans === "N") {
            console.log("User cancelled the transaction.");
            return;
        }
        if (ans !== "y" && ans !== "Y") {
            console.log("Invalid input, please input y or n.");
            return;
        }
        console.log("Waiting for transaction to be mined...");
        const tx = yield wallet.sendTransaction({
            to: receiverAddress,
            value: parsedAmount,
        });
        // wait for the transaction to be mined
        yield tx.wait();
        console.log("Sending transaction hash to zkWasm service...");
        //Then submit the confirmed transaction hash to the zkWasm service.
        yield helper.addPayment({ txhash: tx.hash });
        console.log("Finish addPayment!");
    });
}
exports.addNewPayment = addNewPayment;
function addPaymentWithTx(txhash, resturl) {
    return __awaiter(this, void 0, void 0, function* () {
        let helper = new zkwasm_service_helper_1.ZkWasmServiceHelper(resturl, "", "");
        console.log("Sending transaction hash " + txhash + " to zkWasm service...");
        yield helper.addPayment({ txhash: txhash });
    });
}
exports.addPaymentWithTx = addPaymentWithTx;
function setMaintenanceMode(resturl, priv, active) {
    return __awaiter(this, void 0, void 0, function* () {
        let params = {
            mode: active ? zkwasm_service_helper_1.MaintenanceModeType.Enabled : zkwasm_service_helper_1.MaintenanceModeType.Disabled,
            // TODO: update with real values once nonce verification is implemented
            nonce: 1,
            request_type: zkwasm_service_helper_1.AdminRequestType.MaintenanceMode,
            user_address: yield new ethers_1.Wallet(priv, null).getAddress(),
        };
        let msg = zkwasm_service_helper_1.ZkWasmUtil.createSetMaintenanceModeSignMessage(params);
        let signature;
        try {
            console.log("msg is:", msg);
            signature = yield (0, util_1.signMessage)(msg, priv);
            console.log("signature is:", signature);
        }
        catch (e) {
            console.log("sign error: ", e);
            return;
        }
        let task = Object.assign(Object.assign({}, params), { signature });
        console.log("Setting maintenance mode to", params.mode, "...");
        let helper = new zkwasm_service_helper_1.ZkWasmServiceHelper(resturl, "", "");
        yield helper
            .setMaintenanceMode(task)
            .then((res) => {
            console.log("Set maintenance mode Success", res);
        })
            .catch((err) => {
            console.log("Set maintenance mode Error", err);
        })
            .finally(() => console.log("Finish setMaintenanceMode!"));
    });
}
exports.setMaintenanceMode = setMaintenanceMode;
