"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PublicKey = exports.PrivateKey = exports.Point = exports.CurveField = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const sha256_1 = __importDefault(require("sha256"));
const crypto_1 = __importDefault(require("crypto"));
const field_js_1 = require("./field.js");
class CurveField {
    get modulus() {
        return new bn_js_1.default("21888242871839275222246405745257275088614511777268538073601725287587578984328", 10);
    }
    constructor(v) {
        if (!(v instanceof bn_js_1.default)) {
            v = new bn_js_1.default(v);
        }
        this.v = v.umod(this.modulus);
    }
    add(f) {
        return new CurveField(this.v.add(f.v));
    }
    mul(f) {
        return new CurveField(this.v.mul(f.v));
    }
    sub(f) {
        return new CurveField(this.v.sub(f.v));
    }
    neg() {
        return new CurveField(this.v.neg());
    }
    div(f) {
        return new CurveField(this.v.mul(f.inv().v));
    }
    //see, https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Polynomial_extended_Euclidean_algorithm
    inv() {
        if (this.v.eqn(0)) {
            return this;
        }
        let newt = new bn_js_1.default(1);
        let t = new bn_js_1.default(0);
        let newr = this.v;
        let r = this.modulus;
        let op = (x, newx, q) => {
            return [newx, x.sub(q.mul(newx))];
        };
        while (!newr.eqn(0)) {
            let q = r.div(newr);
            let t_newt = op(t, newt, q);
            t = t_newt[0];
            newt = t_newt[1];
            let r_newr = op(r, newr, q);
            r = r_newr[0];
            newr = r_newr[1];
        }
        return new CurveField(t);
    }
}
exports.CurveField = CurveField;
const constants = {
    c: new field_js_1.Field(8),
    a: new field_js_1.Field(168700),
    d: new field_js_1.Field(168696),
    gX: new field_js_1.Field(new bn_js_1.default("16540640123574156134436876038791482806971768689494387082833631921987005038935", 10)),
    gY: new field_js_1.Field(new bn_js_1.default("20819045374670962167435360035096875258406992893633759881276124905556507972311", 10)),
};
class Point {
    constructor(x, y) {
        this.x = x instanceof field_js_1.Field ? x : new field_js_1.Field(x);
        this.y = y instanceof field_js_1.Field ? y : new field_js_1.Field(y);
    }
    get zero() {
        return new Point(0, 1);
    }
    isZero() {
        return this.x.v.eqn(0) && this.y.v.eqn(1);
    }
    static get base() {
        let gX = constants.gX;
        let gY = constants.gY;
        return new Point(gX, gY);
    }
    add(p) {
        const u1 = this.x;
        const v1 = this.y;
        const u2 = p.x;
        const v2 = p.y;
        //u3 = (u1 * v2 + v1 * u2) / (1 + D * u1 * u2 * v1 * v2)
        let u3_m = u1.mul(v2).add(v1.mul(u2));
        let u3_d = constants.d.mul(u1).mul(u2).mul(v1).mul(v2).add(new field_js_1.Field(1));
        let u3 = u3_m.div(u3_d);
        //v3 = (v1 * v2 - A * u1 * u2) / (1 - D * u1 * u2 * v1 * v2)
        let v3_m = v1.mul(v2).sub(constants.a.mul(u1).mul(u2));
        let v3_d = new field_js_1.Field(1).sub(constants.d.mul(u1).mul(u2).mul(v1).mul(v2));
        let v3 = v3_m.div(v3_d);
        return new Point(u3, v3);
    }
    mul(p) {
        if (p instanceof CurveField) {
            p = p.v;
        }
        else if (!(p instanceof bn_js_1.default)) {
            p = new bn_js_1.default(p);
        }
        let t = p;
        let sum = this.zero;
        let acc = this;
        while (!t.eqn(0)) {
            if (t.mod(new bn_js_1.default(2)).eqn(1)) {
                sum = sum.add(acc);
            }
            acc = acc.add(acc);
            t = t.shrn(1);
        }
        return sum;
    }
}
exports.Point = Point;
class PrivateKey {
    constructor(key) {
        this.key = key;
    }
    // I don"t know why, but most implementation not follow standard
    // https://datatracker.ietf.org/doc/html/rfc8032#section-5.2.5
    static random() {
        return new PrivateKey(new CurveField(new bn_js_1.default(crypto_1.default.randomBytes(32))));
    }
    static fromString(str) {
        new PrivateKey(new CurveField(new bn_js_1.default(str, "hex")));
    }
    toString() {
        return this.key.v.toString("hex");
    }
    r() {
        // TODO: refine later
        return new CurveField(new bn_js_1.default(crypto_1.default.randomBytes(32)));
    }
    get publicKey() {
        if (!this.pubk) {
            this.pubk = PublicKey.fromPrivateKey(this);
        }
        return this.pubk;
    }
    sign(message) {
        let Ax = this.publicKey.key.x;
        let r = this.r();
        let R = Point.base.mul(r);
        let Rx = R.x;
        let content = [];
        content = content.concat(Rx.v.toArray("be", 32));
        content = content.concat(Ax.v.toArray("be", 32));
        content = content.concat(message);
        let H = new bn_js_1.default((0, sha256_1.default)(content), "hex");
        console.log(H.toArray());
        let S = r.add(this.key.mul(new CurveField(H)));
        return [[R.x.v, R.y.v], S.v];
    }
}
exports.PrivateKey = PrivateKey;
class PublicKey {
    constructor(key) {
        this.key = key;
    }
    static fromPrivateKey(pk) {
        return new PublicKey(Point.base.mul(pk.key));
    }
}
exports.PublicKey = PublicKey;
