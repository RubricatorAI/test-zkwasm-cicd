"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MerkleTreeDb = exports.default_snapshot_id = exports.all_collections = exports.snapshot_id_collection = exports.logging_collection = exports.merkle_tree_collection = exports.local_uri = void 0;
const mongodb_1 = require("mongodb");
const field_js_1 = require("./field.js");
const bn_js_1 = require("bn.js");
exports.local_uri = "mongodb://localhost:27017/";
exports.merkle_tree_collection = "merkle_tree";
exports.logging_collection = "merkle_tree_logging";
exports.snapshot_id_collection = "merkle_tree_snapshot_id";
exports.all_collections = [
    exports.merkle_tree_collection,
    exports.logging_collection,
    exports.snapshot_id_collection
];
function normalize_to_string(arg) {
    return arg.toString();
}
function normalize_to_long(arg) {
    return typeof arg === "string" ? mongodb_1.Long.fromString(arg) : arg;
}
// Default snapshot_id when MerkleTree.currentSnapshotIdx is undefined.
// We use 0 so that all valid snapshot id (>= 0) within logging db can
// restore it to initial value.
exports.default_snapshot_id = "0";
class MerkleTreeDb {
    constructor(uri, db_name) {
        this.client = new mongodb_1.MongoClient(uri);
        this.db_name = db_name;
        this.connected = false;
    }
    getMongoClient() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.connected) {
                yield this.client.connect();
                this.connected = true;
            }
            return this.client;
        });
    }
    closeMongoClient() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.connected) {
                yield this.client.close();
                this.connected = false;
            }
        });
    }
    cb_on_db(cb) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield this.getMongoClient();
            const database = client.db(this.db_name);
            return yield cb(database);
        });
    }
    cb_on_db_tx(cb) {
        return __awaiter(this, void 0, void 0, function* () {
            const client = yield this.getMongoClient();
            const database = client.db(this.db_name);
            return yield client.withSession((session) => __awaiter(this, void 0, void 0, function* () { return yield session.withTransaction(() => __awaiter(this, void 0, void 0, function* () { return yield cb(database); })); }));
        });
    }
    cb_on_collection(collection, cb) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.cb_on_db((database) => __awaiter(this, void 0, void 0, function* () {
                const coll = database.collection(collection);
                return yield cb(coll);
            }));
        });
    }
    findOne(filter, collection) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.cb_on_collection(collection, (coll) => __awaiter(this, void 0, void 0, function* () {
                return yield coll.findOne(filter);
            }));
            return result === null ? undefined : result;
        });
    }
    /* update a doc, if not found then insert one */
    updateOne(filter, doc, collection) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.cb_on_collection(collection, (coll) => __awaiter(this, void 0, void 0, function* () {
                return yield coll.replaceOne(filter, doc, { upsert: true });
            }));
        });
    }
    updateWithLogging(filter, doc, logging) {
        return __awaiter(this, void 0, void 0, function* () {
            const query_old_log = {
                path: doc.path,
                snapshot: logging.snapshot,
            };
            yield this.cb_on_db_tx((database) => __awaiter(this, void 0, void 0, function* () {
                const live_collection = database.collection(exports.merkle_tree_collection);
                yield live_collection.replaceOne(filter, doc, { upsert: true });
                const log_collection = database.collection(exports.logging_collection);
                const old_logging = yield log_collection.findOne(query_old_log);
                if (old_logging === null) {
                    yield log_collection.insertOne(logging);
                }
                else {
                    logging.old_field = old_logging.old_field;
                    logging.old_snapshot = old_logging.old_snapshot;
                    yield log_collection.replaceOne(old_logging, logging);
                }
            }));
        });
    }
    /*
     * Update merkly tree with logging
     */
    updatePathLogging(k, old_value, new_value, _old_ss, _ss) {
        const old_ss = normalize_to_string(_old_ss);
        const ss = normalize_to_string(_ss);
        const query = {
            path: k,
        };
        const doc = {
            path: k,
            field: new_value.v.toString(16),
            snapshot: normalize_to_long(ss),
        };
        const log = {
            path: k,
            old_field: old_value.v.toString(16),
            field: new_value.v.toString(16),
            old_snapshot: normalize_to_long(old_ss),
            snapshot: normalize_to_long(ss),
        };
        return this.updateWithLogging(query, doc, log);
    }
    /*
     * query merkle tree node
     */
    queryMerkleTreeNodeFromPath(k) {
        return __awaiter(this, void 0, void 0, function* () {
            const query = {
                path: k,
            };
            const doc = yield this.findOne(query, exports.merkle_tree_collection);
            return (doc && {
                path: k,
                field: new field_js_1.Field(new bn_js_1.BN(doc.field, 16)),
                snapshot: doc.snapshot,
            });
        });
    }
    /*
     * Snapshot
     */
    updateLatestSnapshotId(_id) {
        const doc = {
            snapshot_id: normalize_to_long(_id),
        };
        return this.updateOne({}, doc, exports.snapshot_id_collection);
    }
    queryLatestSnapshotId() {
        return __awaiter(this, void 0, void 0, function* () {
            let node = yield this.findOne({}, exports.snapshot_id_collection);
            return node === undefined
                ? exports.default_snapshot_id
                : node.snapshot_id.toString();
        });
    }
    restoreMerkleTree(_snapshot) {
        return __awaiter(this, void 0, void 0, function* () {
            const snapshot = normalize_to_long(_snapshot);
            yield this.cb_on_db_tx((database) => __awaiter(this, void 0, void 0, function* () {
                const live_collection = database.collection(exports.merkle_tree_collection);
                const log_collection = database.collection(exports.logging_collection);
                const path_should_revert = yield log_collection
                    .aggregate([
                    { $match: { snapshot: { $gt: snapshot } } },
                    { $sort: { snapshot: 1 } },
                    { $group: { _id: "$path", firstLog: { $first: "$$ROOT" } } },
                ])
                    .toArray();
                for (const path of path_should_revert) {
                    const log = path.firstLog;
                    let live_node = yield live_collection.findOne({ path: log.path });
                    let rollback_doc = {
                        path: log.path,
                        field: log.old_field,
                        snapshot: log.old_snapshot,
                    };
                    yield live_collection.replaceOne(live_node, rollback_doc);
                }
                yield log_collection.deleteMany({ snapshot: { $gt: snapshot } });
            }));
        });
    }
}
exports.MerkleTreeDb = MerkleTreeDb;
