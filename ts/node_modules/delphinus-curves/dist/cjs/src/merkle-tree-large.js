"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MerkleTree = exports.BlockSize = exports.BlockShift = exports.MaxHeight = void 0;
const field_js_1 = require("./field.js");
const poseidon_js_1 = require("./poseidon.js");
const db_js_1 = require("./db.js");
const lru_cache_1 = __importDefault(require("lru-cache"));
const hash = poseidon_js_1.poseidon;
exports.MaxHeight = 16;
exports.BlockShift = 2;
exports.BlockSize = 1 << exports.BlockShift;
const cacheOptions = {};
cacheOptions.max = 100;
cacheOptions.maxAge = 60 * 1000;
class MerkleTree {
    constructor(memData = false) {
        this.currentSnapshotIdx = undefined;
        if (memData) {
            this.inMemoryMerkleTree = new Map();
        }
        else {
            this.cache = new lru_cache_1.default(10000);
            this.db = new db_js_1.MerkleTreeDb(db_js_1.local_uri, MerkleTree.dbName);
        }
    }
    static emptyNodeHash(height) {
        if (this.emptyHashes.length === 0) {
            this.emptyHashes.push(new field_js_1.Field(0));
            for (let i = 0; i < exports.MaxHeight; i++) {
                const last = this.emptyHashes[i];
                this.emptyHashes.push(hash([last, last, last, last]));
            }
            this.emptyHashes = this.emptyHashes.reverse();
        }
        return this.emptyHashes[height];
    }
    getRawNode(mtIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.db.queryMerkleTreeNodeFromPath(mtIndex + "I");
        });
    }
    getNode(mtIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            if (mtIndex.startsWith("-")) {
                throw new Error(mtIndex);
            }
            // in-memory merkle tree
            if (this.inMemoryMerkleTree !== undefined) {
                return this.inMemoryMerkleTree.get(mtIndex + "I");
            }
            let field = this.cache.get(mtIndex);
            if (field !== undefined) {
                return field;
            }
            else {
                let node = yield this.getRawNode(mtIndex);
                return node === undefined ? undefined : node.field;
            }
        });
    }
    setNode(mtIndex, value) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this.inMemoryMerkleTree !== undefined) {
                return this.inMemoryMerkleTree.set(mtIndex + "I", value);
            }
            if (this.currentSnapshotIdx === undefined) {
                throw new Error("snapshot not set");
            }
            else {
                let oldDoc = (yield this.getRawNode(mtIndex)) || undefined;
                yield this.db.updatePathLogging(mtIndex + "I", (oldDoc === null || oldDoc === void 0 ? void 0 : oldDoc.field) !== undefined
                    ? oldDoc.field
                    : MerkleTree.emptyNodeHash(mtIndex.length), value, (_a = oldDoc === null || oldDoc === void 0 ? void 0 : oldDoc.snapshot) !== null && _a !== void 0 ? _a : db_js_1.default_snapshot_id, this.currentSnapshotIdx);
            }
            this.cache.set(mtIndex, value);
        });
    }
    startSnapshot(id) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.inMemoryMerkleTree !== undefined) {
                return;
            }
            this.currentSnapshotIdx = id;
        });
    }
    endSnapshot() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.inMemoryMerkleTree !== undefined) {
                return;
            }
            yield this.db.updateLatestSnapshotId(this.currentSnapshotIdx);
            this.currentSnapshotIdx = undefined;
        });
    }
    lastestSnapshot() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.inMemoryMerkleTree !== undefined
                ? "0"
                : this.db.queryLatestSnapshotId();
        });
    }
    loadSnapshot(latest_snapshot) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.inMemoryMerkleTree !== undefined) {
                return;
            }
            yield this.db.restoreMerkleTree(latest_snapshot);
            this.cache.reset();
        });
    }
    closeDb() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.inMemoryMerkleTree !== undefined) {
                return;
            }
            yield this.db.closeMongoClient();
        });
    }
    getNodeOrDefault(mtIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            let value = yield this.getNode(mtIndex);
            if (value === undefined) {
                value = MerkleTree.emptyNodeHash(mtIndex.length);
            }
            return value;
        });
    }
    getNodeOrCreate(mtIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            let value = yield this.getNode(mtIndex);
            if (value === undefined) {
                value = MerkleTree.emptyNodeHash(mtIndex.length);
                yield this.setNode(mtIndex, value);
            }
            return value;
        });
    }
    convertToMtIndex(index) {
        // toString() may get negative value
        let ret = "";
        for (let i = 0; i < exports.MaxHeight; i++) {
            ret = ((index >> (i * 2)) & 3).toString() + ret;
        }
        return ret;
    }
    fillPath(index) {
        return __awaiter(this, void 0, void 0, function* () {
            const mtIndex = this.convertToMtIndex(index);
            for (let i = 0; i < exports.MaxHeight; i++) {
                yield this.getNodeOrCreate(mtIndex.slice(0, i));
            }
            return yield this.getPath(index);
        });
    }
    getPath(index) {
        return __awaiter(this, void 0, void 0, function* () {
            const ret = {
                root: yield this.getNodeOrDefault(""),
                index: index,
                pathDigests: [],
            };
            const mtIndex = this.convertToMtIndex(index);
            for (let i = 0; i < exports.MaxHeight; i++) {
                const digests = yield Promise.all(
                // Used to generate [0, 1, ..., BlockSize]
                Array.from(Array(exports.BlockSize).keys()).map((v) => this.getNodeOrDefault(mtIndex.slice(0, i) + v)));
                ret.pathDigests.push(digests);
            }
            return ret;
        });
    }
    getLeave(index) {
        return __awaiter(this, void 0, void 0, function* () {
            const mtIndex = this.convertToMtIndex(index);
            return yield this.getNodeOrDefault(mtIndex);
        });
    }
    getChildren(mtIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield Promise.all(Array.from(Array(exports.BlockSize).keys()).map((v) => this.getNodeOrDefault(mtIndex + v)));
        });
    }
    getLeaves(index) {
        return __awaiter(this, void 0, void 0, function* () {
            const mtIndex = this.convertToMtIndex(index);
            return this.getChildren(mtIndex.slice(0, exports.MaxHeight - 1));
        });
    }
    updateHash(index) {
        return __awaiter(this, void 0, void 0, function* () {
            const mtIndex = this.convertToMtIndex(index);
            for (let i = 0; i < exports.MaxHeight; i++) {
                const layer = exports.MaxHeight - i - 1;
                const layerIndex = mtIndex.slice(0, layer);
                const children = yield this.getChildren(layerIndex);
                const value = hash(children);
                yield this.setNode(layerIndex, value);
            }
        });
    }
    getRoot() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.getNodeOrDefault("");
        });
    }
    setLeave(index, value) {
        return __awaiter(this, void 0, void 0, function* () {
            const mtIndex = this.convertToMtIndex(index);
            const path = yield this.fillPath(index);
            yield this.setNode(mtIndex, value);
            yield this.updateHash(index);
            return path;
        });
    }
    setLeaves(index, values) {
        return __awaiter(this, void 0, void 0, function* () {
            if (values.length != exports.BlockSize) {
                throw new Error(`Invalid leaves length: ${values.length}`);
            }
            const mtIndex = this.convertToMtIndex(index);
            const path = yield this.fillPath(index);
            yield Promise.all(
            // Used to generate [0, 1, ..., BlockSize]
            Array.from(Array(exports.BlockSize).keys()).map((v) => this.setNode(mtIndex.slice(0, exports.MaxHeight - 1) + v, values[v])));
            yield this.updateHash(index);
            return path;
        });
    }
}
exports.MerkleTree = MerkleTree;
MerkleTree.dbName = "delphinus";
MerkleTree.emptyHashes = [];
