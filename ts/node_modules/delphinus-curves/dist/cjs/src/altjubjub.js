"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.PublicKey = exports.PrivateKey = exports.bnToHexLe = exports.Point = exports.CurveField = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const sha256_1 = __importDefault(require("sha256"));
const crypto_1 = __importDefault(require("crypto"));
const field_js_1 = require("./field.js");
class CurveField {
    get modulus() {
        return new bn_js_1.default("2736030358979909402780800718157159386076813972158567259200215660948447373041", 10);
    }
    constructor(v) {
        if (!(v instanceof bn_js_1.default)) {
            v = new bn_js_1.default(v);
        }
        this.v = v.umod(this.modulus);
    }
    add(f) {
        return new CurveField(this.v.add(f.v));
    }
    mul(f) {
        return new CurveField(this.v.mul(f.v));
    }
    sub(f) {
        return new CurveField(this.v.sub(f.v));
    }
    neg() {
        return new CurveField(this.v.neg());
    }
    div(f) {
        return new CurveField(this.v.mul(f.inv().v));
    }
    //see, https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Polynomial_extended_Euclidean_algorithm
    inv() {
        if (this.v.eqn(0)) {
            return this;
        }
        let newt = new bn_js_1.default(1);
        let t = new bn_js_1.default(0);
        let newr = this.v;
        let r = this.modulus;
        let op = (x, newx, q) => {
            return [newx, x.sub(q.mul(newx))];
        };
        while (!newr.eqn(0)) {
            let q = r.div(newr);
            let t_newt = op(t, newt, q);
            t = t_newt[0];
            newt = t_newt[1];
            let r_newr = op(r, newr, q);
            r = r_newr[0];
            newr = r_newr[1];
        }
        return new CurveField(t);
    }
}
exports.CurveField = CurveField;
const constants = {
    c: new field_js_1.Field(0),
    a: new field_js_1.Field(new bn_js_1.default("21888242871839275222246405745257275088548364400416034343698204186575808495616", 10)),
    d: new field_js_1.Field(new bn_js_1.default("12181644023421730124874158521699555681764249180949974110617291017600649128846", 10)),
    gX: new field_js_1.Field(new bn_js_1.default("21237458262955047976410108958495203094252581401952870797780751629344472264183", 10)),
    gY: new field_js_1.Field(new bn_js_1.default("2544379904535866821506503524998632645451772693132171985463128613946158519479", 10)),
};
class Point {
    constructor(x, y) {
        this.x = x instanceof field_js_1.Field ? x : new field_js_1.Field(x);
        this.y = y instanceof field_js_1.Field ? y : new field_js_1.Field(y);
    }
    get zero() {
        return new Point(0, 1);
    }
    isZero() {
        return this.x.v.eqn(0) && this.y.v.eqn(1);
    }
    static get base() {
        let gX = constants.gX;
        let gY = constants.gY;
        return new Point(gX, gY);
    }
    add(p) {
        const u1 = this.x;
        const v1 = this.y;
        const u2 = p.x;
        const v2 = p.y;
        //u3 = (u1 * v2 + v1 * u2) / (1 + D * u1 * u2 * v1 * v2)
        let u3_m = u1.mul(v2).add(v1.mul(u2));
        let u3_d = constants.d.mul(u1).mul(u2).mul(v1).mul(v2).add(new field_js_1.Field(1));
        let u3 = u3_m.div(u3_d);
        //v3 = (v1 * v2 - A * u1 * u2) / (1 - D * u1 * u2 * v1 * v2)
        let v3_m = v1.mul(v2).sub(constants.a.mul(u1).mul(u2));
        let v3_d = new field_js_1.Field(1).sub(constants.d.mul(u1).mul(u2).mul(v1).mul(v2));
        let v3 = v3_m.div(v3_d);
        return new Point(u3, v3);
    }
    mul(p) {
        if (p instanceof CurveField) {
            p = p.v;
        }
        else if (!(p instanceof bn_js_1.default)) {
            p = new bn_js_1.default(p);
        }
        let t = p;
        let sum = this.zero;
        let acc = this;
        while (!t.eqn(0)) {
            if (t.mod(new bn_js_1.default(2)).eqn(1)) {
                sum = sum.add(acc);
            }
            acc = acc.add(acc);
            t = t.shrn(1);
        }
        return sum;
    }
}
exports.Point = Point;
function u8ToHex(u8Array) {
    return Array.from(u8Array)
        .map(byte => byte.toString(16).padStart(2, '0'))
        .join('');
}
function bnToHexLe(n, sz = 32) {
    let bytes = n.toArray("le", sz);
    let v = new Uint8Array(sz);
    for (var i = 0; i < sz; i++) {
        v[i] = bytes[i];
    }
    return u8ToHex(v);
}
exports.bnToHexLe = bnToHexLe;
class PrivateKey {
    constructor(key) {
        this.key = key;
    }
    // I don"t know why, but most implementation not follow standard
    // https://datatracker.ietf.org/doc/html/rfc8032#section-5.2.5
    static random() {
        return new PrivateKey(new CurveField(new bn_js_1.default(crypto_1.default.randomBytes(32))));
    }
    static fromString(str) {
        return new PrivateKey(new CurveField(new bn_js_1.default(str, "hex")));
    }
    toString() {
        return this.key.v.toString("hex");
    }
    r() {
        // TODO: refine later
        return new CurveField(new bn_js_1.default(crypto_1.default.randomBytes(32)));
    }
    get publicKey() {
        if (!this.pubk) {
            this.pubk = PublicKey.fromPrivateKey(this);
        }
        return this.pubk;
    }
    hashMessage(msg) {
        const hash = (0, sha256_1.default)(Buffer.from(msg));
        return new bn_js_1.default(hash, "hex");
    }
    sign(message) {
        let r = this.r();
        let R = Point.base.mul(r);
        let H = this.hashMessage(message);
        let bytesPacked = H.toString("hex", 64);
        console.log("Signing messag:", bytesPacked);
        console.log(H.toArray());
        console.log("Message in little endian:");
        console.log(bnToHexLe(H));
        console.log("----------------------------------");
        let S = r.add(this.key.mul(new CurveField(H)));
        return [[R.x.v, R.y.v], S.v];
    }
}
exports.PrivateKey = PrivateKey;
class PublicKey {
    constructor(key) {
        this.key = key;
    }
    static fromPrivateKey(pk) {
        return new PublicKey(Point.base.mul(pk.key));
    }
}
exports.PublicKey = PublicKey;
