"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MerkleTree = exports.MaxHeight = void 0;
const field_js_1 = require("./field.js");
const poseidon_js_1 = require("./poseidon.js");
const hash = poseidon_js_1.poseidon;
exports.MaxHeight = 16;
class MerkleTree {
    constructor() {
        this.root = MerkleTree.emptyNode(exports.MaxHeight);
    }
    static emptyNodeHash(height) {
        if (this.emptyHashes.length === 0) {
            this.emptyHashes.push(new field_js_1.Field(0));
            for (let i = 0; i < exports.MaxHeight; i++) {
                const last = this.emptyHashes[i];
                this.emptyHashes.push(hash([last, last, last, last]));
            }
        }
        return this.emptyHashes[height];
    }
    static emptyNode(height) {
        return {
            value: this.emptyNodeHash(height),
            children: height === 0 ? [] : [undefined, undefined, undefined, undefined]
        };
    }
    getPath(index) {
        var _a;
        const ret = {
            root: this.root.value,
            index: index,
            pathDigests: []
        };
        let curr = this.root;
        for (let level = exports.MaxHeight; level >= 1; level--) {
            ret.pathDigests.push(curr.children.map(n => { var _a; return (_a = n === null || n === void 0 ? void 0 : n.value) !== null && _a !== void 0 ? _a : MerkleTree.emptyNodeHash(level - 1); }));
            const offset = (index >> ((level - 1) * 2)) & 3;
            curr = (_a = curr.children[offset]) !== null && _a !== void 0 ? _a : MerkleTree.emptyNode(level);
        }
        return ret;
    }
    _fillPath(index) {
        var _a;
        const path = [];
        let curr = this.root;
        path.push(curr);
        for (let level = exports.MaxHeight - 1; level >= 0; level--) {
            const offset = (index >> (level * 2)) & 3;
            const next = (_a = curr.children[offset]) !== null && _a !== void 0 ? _a : MerkleTree.emptyNode(level);
            curr.children[offset] = next;
            curr = next;
            path.push(curr);
        }
        return path;
    }
    getLeave(index) {
        var _a, _b;
        const path = this._fillPath(index);
        return (_b = (_a = path[path.length - 1]) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : new field_js_1.Field(0);
    }
    getLeaves(index) {
        var _a;
        const path = this._fillPath(index);
        path.pop();
        return (_a = path[path.length - 1]) === null || _a === void 0 ? void 0 : _a.children.map(child => { var _a; return (_a = child === null || child === void 0 ? void 0 : child.value) !== null && _a !== void 0 ? _a : new field_js_1.Field(0); });
    }
    _updateHash(path) {
        for (let level = 1; level <= exports.MaxHeight; level++) {
            const _curr = path.pop();
            const _childrenValues = _curr.children.map(n => { var _a; return (_a = n === null || n === void 0 ? void 0 : n.value) !== null && _a !== void 0 ? _a : MerkleTree.emptyNodeHash(level - 1); });
            _curr.value = hash(_childrenValues);
            //console.log(`level ${level}`);
            //console.log(`children ${_childrenValues.map(v => v.v.toString(10)).join(", ")}`);
            //console.log(`hash ${_curr.value.v.toString(10)}`);
        }
    }
    setLeave(index, value) {
        const path = this._fillPath(index);
        const leaf = path.pop();
        leaf.value = value;
        //console.log('set value ' + value.v.toString(10));
        this._updateHash(path);
        //console.log('root hash is ' + this.root.value.v.toString(10));
    }
    setLeaves(index, values) {
        if (values.length != 4) {
            throw new Error(`Invalid leaves length: ${values.length}`);
        }
        const path = this._fillPath(index);
        const _leaf = path.pop();
        //console.log('set values ' + values.map(value => value.v.toString(10)).join(" "));
        path[path.length - 1].children = values.map(value => ({ value, children: [] }));
        this._updateHash(path);
        //console.log('root hash is ' + this.root.value.v.toString(10));
    }
    getRoot() {
        return this.root.value;
    }
}
exports.MerkleTree = MerkleTree;
MerkleTree.emptyHashes = [];
