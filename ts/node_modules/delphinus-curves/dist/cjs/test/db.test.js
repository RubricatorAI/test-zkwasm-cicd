"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const field_1 = require("../src/field");
const merkle_tree_large_1 = require("../src/merkle-tree-large");
var assert = require('assert');
function convertToMtIndex(index) {
    // toString() may get negative value
    let ret = "";
    for (let i = 0; i < 16; i++) {
        ret = ((index >> (i * 2)) & 3).toString() + ret;
    }
    return ret;
}
function testDBMerkleTree() {
    return __awaiter(this, void 0, void 0, function* () {
        const merkle_tree = new merkle_tree_large_1.MerkleTree();
        yield merkle_tree.loadSnapshot("0");
        yield merkle_tree.startSnapshot("1");
        yield merkle_tree.setNode("0001", new field_1.Field(1));
        yield merkle_tree.setNode("0002", new field_1.Field(2));
        yield merkle_tree.setNode("0003", new field_1.Field(3));
        yield merkle_tree.getNode("0001").then((node) => {
            assert.ok(node.v.eq(new field_1.Field(1).v));
        });
        yield merkle_tree.startSnapshot("2");
        yield merkle_tree.setNode("0001", new field_1.Field(19));
        yield merkle_tree.endSnapshot();
        yield merkle_tree.lastestSnapshot().then((node) => {
            assert.equal(node, "2");
        });
        yield merkle_tree.getNode("0001").then((node) => {
            assert.ok(node.v.eq(new field_1.Field(19).v));
        });
        yield merkle_tree.loadSnapshot("1");
        yield merkle_tree.getNode("0001").then((node) => {
            assert.ok(node.v.eq(new field_1.Field(1).v));
        });
        yield merkle_tree.loadSnapshot("0");
        yield merkle_tree.getNode("0001").then((node) => {
            assert.ok(node.v.eq(merkle_tree_large_1.MerkleTree.emptyNodeHash(4).v));
        });
        yield merkle_tree.startSnapshot("1");
        yield merkle_tree.setNode("0001", new field_1.Field(1));
        yield merkle_tree.setNode("0001", new field_1.Field(2));
        yield merkle_tree.setNode("0001", new field_1.Field(3));
        yield merkle_tree.endSnapshot();
        yield merkle_tree.startSnapshot("2");
        yield merkle_tree.setNode("0001", new field_1.Field(4));
        yield merkle_tree.endSnapshot();
        yield merkle_tree.loadSnapshot("0");
        yield merkle_tree.getNode("0001").then((node) => {
            assert.ok(node.v.eq(merkle_tree_large_1.MerkleTree.emptyNodeHash(4).v));
        });
        yield merkle_tree.loadSnapshot("0");
        yield merkle_tree.startSnapshot("1");
        yield merkle_tree.setNode("0", new field_1.Field(1));
        yield merkle_tree.setLeave(0, new field_1.Field(2)).then((path) => {
            assert.equal(path.pathDigests[0][0].v.toNumber(), 1);
        });
        yield merkle_tree.getNode(convertToMtIndex(0)).then((node) => {
            assert.equal(node.v.toNumber(), 2);
        });
        yield merkle_tree.endSnapshot();
        yield merkle_tree.closeDb();
    });
}
function testInMemoryMerkleTree() {
    return __awaiter(this, void 0, void 0, function* () {
        const merkle_tree = new merkle_tree_large_1.MerkleTree(true);
        yield merkle_tree.getNode("0001").then((node) => {
            assert.ok(node === undefined);
        });
        yield merkle_tree.setNode("0001", new field_1.Field(1));
        yield merkle_tree.getNode("0001").then((node) => {
            assert.ok(node.v.eq(new field_1.Field(1).v));
        });
        // lastestSnapshot should always return string "0"
        yield merkle_tree.lastestSnapshot().then((node) => {
            assert.equal(node, "0");
        });
        // should do nothing
        yield merkle_tree.loadSnapshot("0");
        yield merkle_tree.endSnapshot();
        yield merkle_tree.closeDb();
    });
}
function main() {
    return __awaiter(this, void 0, void 0, function* () {
        yield testDBMerkleTree();
        yield testInMemoryMerkleTree();
    });
}
main().then(() => console.log("done"));
